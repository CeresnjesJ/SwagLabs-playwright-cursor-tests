# SauceDemo Playwright Test Automation

Senior QA Automation Engineer - Playwright + TypeScript + Page Object Model

## Code Quality (MANDATORY)

- ✅ **Page Object Model (POM)** - All pages must extend `BasePage`
- ✅ **NO hardcoded values** - Use constants from `test-data/` folder
- ✅ **TypeScript strict mode** - No `any` types
- ✅ **Locator priority**: `#id` → `getByTestId()` → `getByRole()` → `getByLabel()`
- ✅ **NO arbitrary timeouts** - Use `waitFor()` or auto-retrying assertions

## Naming Conventions

- **Classes**: PascalCase (`LoginPage`)
- **Methods**: camelCase (`login()`, `addToCart()`)
- **Files**: `LoginPage.ts`, `login.spec.ts`
- **Constants**: UPPER_SNAKE_CASE (`TEST_USERS`, `ERROR_MESSAGES`)
- **Tests**: `'should [action] when [condition]'`

---

## Page Object Model Rules

### Structure Template
```typescript
export class LoginPage extends BasePage {
  // Private locators
  private readonly _usernameInput: Locator;
  private readonly _passwordInput: Locator;
  private readonly _loginButton: Locator;

  constructor(page: Page) {
    super(page);
    this._usernameInput = page.locator('#user-name');
    this._passwordInput = page.locator('#password');
    this._loginButton = page.locator('#login-button');
  }

  // Public getters
  get usernameInput(): Locator { return this._usernameInput; }
  get loginButton(): Locator { return this._loginButton; }

  // Action methods
  async login(username: string, password: string): Promise<void> {
    await this._usernameInput.fill(username);
    await this._passwordInput.fill(password);
    await this._loginButton.click();
  }

  // Text getter
  async getErrorMessage(): Promise<string> {
    return await this._errorMessage.textContent() || '';
  }
}
```

### Critical Rules
- **All locators**: `private readonly` with `_` prefix
- **Public getters**: Expose locators without `_`
- **One logical action per method** (Single Responsibility)
- **NO assertions in Page Objects** - only interactions
- **NO importing other Page Objects** - avoid circular dependencies
- **Constructor**: Only initialize locators, NO actions

---

## MCP-First Approach (MANDATORY)

**Before creating ANY Page Object:**

1. **Inspect the page with MCP:**
```javascript
{
  inputs: Array.from(document.querySelectorAll('input')).map(el => ({
    id: el.id || null,
    name: el.name || null,
    type: el.type,
    dataTestId: el.getAttribute('data-testid') || null
  })),
  buttons: Array.from(document.querySelectorAll('button')).map(el => ({
    id: el.id || null,
    text: el.textContent?.trim() || null,
    dataTestId: el.getAttribute('data-testid') || null
  }))
}
```

2. **Verify selectors:**
```typescript
browser_verify_element_visible('#user-name')
browser_verify_element_visible('#login-button')
```

3. **Create Page Object using ONLY verified selectors**

### MCP Test Generation Workflow
```
1. generator_setup_page        → Initialize browser
2. browser_navigate            → Go to URL
3. browser_type/browser_click  → Execute test steps
4. browser_verify_*            → Add verifications
5. generator_read_log          → Get execution log
6. generator_write_test        → Create .spec.ts file
```

---

## Locator Strategy (Priority Order)

```typescript
// 1. ID attribute (HIGHEST PRIORITY)
page.locator('#user-name')
page.locator('#login-button')

// 2. data-testid
page.getByTestId('add-to-cart-sauce-labs-backpack')

// 3. Semantic locators
page.getByRole('button', { name: 'Login' })
page.getByLabel('Username')

// 4. Stable CSS (LAST RESORT)
page.locator('.shopping_cart_badge')

// ❌ NEVER use fragile selectors
page.locator('div > ul > li:nth-child(3)')
```

---

## Test Structure (AAA Pattern)

```typescript
import { test, expect } from '@playwright/test';
import { LoginPage } from '../pages/LoginPage';
import { TEST_USERS } from '../test-data/users';

test('should login successfully with valid credentials', async ({ page }) => {
  // ARRANGE
  const loginPage = new LoginPage(page);
  const { username, password } = TEST_USERS.STANDARD_USER;
  
  // ACT
  await loginPage.navigate();
  await loginPage.login(username, password);
  
  // ASSERT
  await expect(page).toHaveURL(/inventory\.html$/);
});
```

---

## Test Data Management

```typescript
// ✅ CORRECT - Use constants
import { TEST_USERS } from '../test-data/users';
import { ERROR_MESSAGES } from '../test-data/messages';

const { username, password } = TEST_USERS.STANDARD_USER;
await loginPage.login(username, password);

// ❌ WRONG - Hardcoded
await loginPage.login('standard_user', 'secret_sauce');
```

---

## Web-First Assertions

```typescript
// ✅ CORRECT - Auto-retrying
await expect(page).toHaveURL(/inventory/);
await expect(page.getByText('Products')).toBeVisible();
await expect(page.locator('.cart_badge')).toHaveText('1');

// ❌ WRONG - Manual waits (flaky!)
await page.waitForTimeout(3000);
```

---

## DO's and DON'Ts

### ✅ ALWAYS DO
- Extend `BasePage` for all Page Objects
- Use ID locators first, then semantic locators
- Import constants from `test-data/` folder
- Use descriptive test names: `'should X when Y'`
- Inspect page with MCP before creating Page Objects

### ❌ NEVER DO
- Use `any` type in TypeScript
- Hardcode credentials, URLs, or test data
- Use `page.waitForTimeout()` (arbitrary waits)
- Put assertions in Page Objects
- Skip MCP inspection when creating Page Objects
- Use fragile CSS selectors like nth-child